/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef LDL_Util_hpp
#define LDL_Util_hpp

#if defined(__BORLANDC__)
#include <mem.h>
#define bool  char 
#define true  1 
#define false 0
#endif
/********************************************************************************************************************************
														 Includes
********************************************************************************************************************************/
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>

#if defined(_WIN32)

#if (!__MINGW32__)
#pragma comment(lib, "gdi32.lib" )
#pragma comment(lib, "winmm.lib" )
#pragma comment(lib, "user32.lib" )
#pragma comment(lib, "opengl32.lib" )
#endif

#define STRICT
#undef UNICODE
#undef _UNICODE

#ifdef NOMINMAX
#include <windows.h>
#else
#define NOMINMAX
#include <windows.h>
#undef NOMINMAX
#endif

#if !defined INVALID_ATOM
#define INVALID_ATOM ((ATOM)0)
#endif

#if !defined INVALID_FILE_ATTRIBUTES
#define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#endif

#if !defined VK_OEM_1
#define VK_OEM_1 0xBA
#endif

#if !defined VK_OEM_2
#define VK_OEM_2 0xBF
#endif

#if !defined VK_OEM_3
#define VK_OEM_3 0xC0
#endif

#if !defined VK_OEM_4
#define VK_OEM_4 0xDB
#endif

#if !defined VK_OEM_5
#define VK_OEM_5 0xDC
#endif

#if !defined VK_OEM_6
#define VK_OEM_6 0xDD
#endif

#if !defined VK_OEM_7
#define VK_OEM_7 0xDE
#endif

#if !defined VK_OEM_PLUS
#define VK_OEM_PLUS 0xBB
#endif

#if !defined VK_OEM_COMMA
#define VK_OEM_COMMA 0xBC
#endif

#if !defined VK_OEM_MINUS
#define VK_OEM_MINUS 0xBD
#endif

#if !defined VK_OEM_PERIOD
#define VK_OEM_PERIOD 0xBE
#endif

#if !defined WM_MOUSEWHEEL
#define WM_MOUSEWHEEL 0x020A
#endif

#if !defined WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif
#elif defined(__unix__)
#include <unistd.h>
#include <sys/time.h>
#include <dlfcn.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <stdint.h>

extern "C" {
#define GLX_USE_GL		      1
#define GLX_BUFFER_SIZE		  2
#define GLX_LEVEL		      3
#define GLX_RGBA		      4
#define GLX_DOUBLEBUFFER	  5
#define GLX_STEREO		      6
#define GLX_AUX_BUFFERS		  7
#define GLX_RED_SIZE		  8
#define GLX_GREEN_SIZE		  9
#define GLX_BLUE_SIZE		  10
#define GLX_ALPHA_SIZE		  11
#define GLX_DEPTH_SIZE		  12
#define GLX_STENCIL_SIZE	  13
#define GLX_ACCUM_RED_SIZE	  14
#define GLX_ACCUM_GREEN_SIZE  15
#define GLX_ACCUM_BLUE_SIZE	  16
#define GLX_ACCUM_ALPHA_SIZE  17

	typedef XID GLXDrawable;
	typedef struct __GLXcontextRec* GLXContext;
	typedef unsigned char	GLubyte;

#define GLX_SAMPLE_BUFFERS              0x186a0 /*100000*/
#define GLX_SAMPLES                     0x186a1 /*100001*/

	extern Bool glXQueryVersion(Display* dpy, int* maj, int* min);
	extern XVisualInfo* glXChooseVisual(Display* dpy, int screen, int* attribList);
	extern GLXContext glXCreateContext(Display* dpy, XVisualInfo* vis, GLXContext shareList, Bool direct);
	extern void glXDestroyContext(Display* dpy, GLXContext ctx);
	extern Bool glXMakeCurrent(Display* dpy, GLXDrawable drawable, GLXContext ctx);
	extern void glXSwapBuffers(Display* dpy, GLXDrawable drawable);
	extern void (*glXGetProcAddress(const GLubyte* procname))(void);
}
#elif defined(__MSDOS__)
#include <dos.h>
#endif
/********************************************************************************************************************************
														       Types
********************************************************************************************************************************/
#if (_MSC_VER <= 1600)
typedef unsigned char uint8_t;
typedef signed char   int8_t;

typedef unsigned short uint16_t;
typedef signed short   int16_t;

typedef unsigned int   uint32_t;
typedef signed int     int32_t;
#else
#include <stdint.h>
#endif
typedef void(*LDL_VoidFuncPtr)(void);
/********************************************************************************************************************************
													       LDL_TestEqual
********************************************************************************************************************************/
void LDL_TestEqual(bool condition, const char* description, const char* function, const char* file, int line)
{
	if (!condition)
	{
		printf("Test failed: %s function %s file %s line %d", description, function, file, line);
	}
}

#define LDL_TEST_EQUAL(x) LDL_TestEqual(x, #x, "__FUNCTION__", __FILE__, __LINE__)
/********************************************************************************************************************************
														  LDL_NumberToString
********************************************************************************************************************************/
class LDL_NumberToString
{
public:
	const char* Convert(int num, uint8_t base = 10)
	{
		int i = 0;
		bool isNegative = false;

		/* Handle 0 explicitly, otherwise empty string is printed for 0 */
		if (num == 0)
		{
			_Buffer[i++] = '0';
			_Buffer[i] = '\0';
		}

		// In standard itoa(), negative numbers are handled only with
		// base 10. Otherwise numbers are considered unsigned.
		if (num < 0 && base == 10)
		{
			isNegative = true;
			num = -num;
		}

		// Process individual digits
		while (num != 0)
		{
			int rem = num % base;
			_Buffer[i++] = (rem > 9) ? (rem - 10) + 'a' : rem + '0';
			num = num / base;
		}

		// If number is negative, append '-'
		if (isNegative)
			_Buffer[i++] = '-';

		_Buffer[i] = '\0'; // Append string terminator

		// Reverse the string
		Reverse(_Buffer, i);

		return _Buffer;
	}

	const char* Convert(size_t num)
	{
		return Convert((int)num, 10);
	}

private:
	void Swap(char& t1, char& t2)
	{
		char tmp = t1;
		t1 = t2;
		t2 = tmp;
	}

	void Reverse(char* str, size_t length)
	{
		size_t start = 0;
		size_t end = length - 1;

		while (start < end)
		{
			Swap(*(str + start), *(str + end));
			start++;
			end--;
		}
	}

	char _Buffer[32];
	int _Result;
};
/********************************************************************************************************************************
														  LDL_Color
********************************************************************************************************************************/
class LDL_Color
{
public:
	LDL_Color() :
#if defined(_WIN32)
		b(0),
		g(0),
		r(0),
#else
		r(0),
		g(0),
		b(0),
#endif
		a(255)
	{
	}

	LDL_Color(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha = 255) :
#if defined(_WIN32)
		b(blue),
		g(green),
		r(red),
#else
		r(red),
		g(green),
		b(blue),
#endif
		a(alpha)
	{
	}

	int toInt() const
	{
		return (int)((r << 24) | (g << 16) | (b << 8) | a);
	}

#if defined(_WIN32)
	uint8_t b;
	uint8_t g;
	uint8_t r;
#else
	uint8_t r;
	uint8_t g;
	uint8_t b;
#endif
	uint8_t a;
};
/********************************************************************************************************************************
														 LDL_Palette
********************************************************************************************************************************/
class LDL_Palette
{
public:
	enum
	{
		Max = 256
	};

	LDL_Palette()
	{
		memset(&_Colors, 0, sizeof(_Colors));
	}

	const LDL_Color& Get(size_t index)
	{
		assert(index < Max);

		return _Colors[index];
	}

	void Set(size_t index, const LDL_Color& color)
	{
		assert(index < Max);

		_Colors[index] = color;
	}
private:
	LDL_Color _Colors[Max];
};
/********************************************************************************************************************************
														  LDL_Mat4f
********************************************************************************************************************************/
class LDL_Mat4f
{
public:
	LDL_Mat4f()
	{
		Identity();
	}

	LDL_Mat4f& operator=(const LDL_Mat4f& source)
	{
		if (this == &source)
			return *this;

		memcpy(&_Values, source._Values, sizeof(_Values));

		return *this;
	}

	float* Values()
	{
		return _Values;
	}

	void Identity()
	{
		_Values[0] = 1;
		_Values[1] = 0;
		_Values[2] = 0;
		_Values[3] = 0;
		_Values[4] = 0;
		_Values[5] = 1;
		_Values[6] = 0;
		_Values[7] = 0;
		_Values[8] = 0;
		_Values[9] = 0;
		_Values[10] = 1;
		_Values[11] = 0;
		_Values[12] = 0;
		_Values[13] = 0;
		_Values[14] = 0;
		_Values[15] = 1;
	}

	LDL_Mat4f operator * (const LDL_Mat4f& m) const {
		LDL_Mat4f ret;

		ret._Values[0] = ((_Values[0] * m._Values[0]) + (_Values[1] * m._Values[4]) + (_Values[2] * m._Values[8]) + (_Values[3] * m._Values[12]));
		ret._Values[1] = ((_Values[0] * m._Values[1]) + (_Values[1] * m._Values[5]) + (_Values[2] * m._Values[9]) + (_Values[3] * m._Values[13]));
		ret._Values[2] = ((_Values[0] * m._Values[2]) + (_Values[1] * m._Values[6]) + (_Values[2] * m._Values[10]) + (_Values[3] * m._Values[14]));
		ret._Values[3] = ((_Values[0] * m._Values[3]) + (_Values[1] * m._Values[7]) + (_Values[2] * m._Values[11]) + (_Values[3] * m._Values[15]));

		ret._Values[4] = ((_Values[4] * m._Values[0]) + (_Values[5] * m._Values[4]) + (_Values[6] * m._Values[8]) + (_Values[7] * m._Values[12]));
		ret._Values[5] = ((_Values[4] * m._Values[1]) + (_Values[5] * m._Values[5]) + (_Values[6] * m._Values[9]) + (_Values[7] * m._Values[13]));
		ret._Values[6] = ((_Values[4] * m._Values[2]) + (_Values[5] * m._Values[6]) + (_Values[6] * m._Values[10]) + (_Values[7] * m._Values[14]));
		ret._Values[7] = ((_Values[4] * m._Values[3]) + (_Values[5] * m._Values[7]) + (_Values[6] * m._Values[11]) + (_Values[7] * m._Values[15]));

		ret._Values[8] = ((_Values[8] * m._Values[0]) + (_Values[9] * m._Values[4]) + (_Values[10] * m._Values[8]) + (_Values[11] * m._Values[12]));
		ret._Values[9] = ((_Values[8] * m._Values[1]) + (_Values[9] * m._Values[5]) + (_Values[10] * m._Values[9]) + (_Values[11] * m._Values[13]));
		ret._Values[10] = ((_Values[8] * m._Values[2]) + (_Values[9] * m._Values[6]) + (_Values[10] * m._Values[10]) + (_Values[11] * m._Values[14]));
		ret._Values[11] = ((_Values[8] * m._Values[3]) + (_Values[9] * m._Values[7]) + (_Values[10] * m._Values[11]) + (_Values[11] * m._Values[15]));

		ret._Values[12] = ((_Values[12] * m._Values[0]) + (_Values[13] * m._Values[4]) + (_Values[14] * m._Values[8]) + (_Values[15] * m._Values[12]));
		ret._Values[13] = ((_Values[12] * m._Values[1]) + (_Values[13] * m._Values[5]) + (_Values[14] * m._Values[9]) + (_Values[15] * m._Values[13]));
		ret._Values[14] = ((_Values[12] * m._Values[2]) + (_Values[13] * m._Values[6]) + (_Values[14] * m._Values[10]) + (_Values[15] * m._Values[14]));
		ret._Values[15] = ((_Values[12] * m._Values[3]) + (_Values[13] * m._Values[7]) + (_Values[14] * m._Values[11]) + (_Values[15] * m._Values[15]));

		return ret;
	}

	float _Values[16];
};
/********************************************************************************************************************************
												LDL_Mat4f - functions
********************************************************************************************************************************/
LDL_Mat4f Ortho(float left, float right, float bottom, float top, float farv, float nearv)
{
	LDL_Mat4f result;

	result._Values[0] = (2.0f / (right - left));
	result._Values[5] = (2.0f / (top - bottom));
	result._Values[10] = (-1.0);
	result._Values[12] = (-(right + left) / (right - left));
	result._Values[13] = (-(top + bottom) / (top - bottom));
	result._Values[14] = (-(farv + nearv) / (farv - nearv));

	return result;
}
/********************************************************************************************************************************
														LDL_Vec2i
********************************************************************************************************************************/
class LDL_Vec2i
{
public:
	LDL_Vec2i() :
		x(0),
		y(0)
	{
	}

	LDL_Vec2i(int x, int y) :
		x(x),
		y(y)
	{
	}

	int x;
	int y;
};
/********************************************************************************************************************************
														LDL_Result
********************************************************************************************************************************/
class LDL_Result
{
public:
	enum
	{
		Max = 64
	};

	LDL_Result()
	{
		Clear();
	}

	void Clear()
	{
		_Ok = true;
		memset(&_Message, 0, Max);
	}

	bool Ok()
	{
		return _Ok;
	}

	const char* Message()
	{
		return _Message;
	}

	void Message(const char* message, const char* detail)
	{
		Clear();

		_Ok = false;

		size_t count = strlen(message) + strlen(detail);
		assert(count < Max);

		strcpy(_Message, message);
		strcat(_Message, detail);
	}

	void Message(const char* message)
	{
		Message(message, "");
	}
private:
	bool _Ok;
	char _Message[Max];
};
/********************************************************************************************************************************
														  LDL_Abort
********************************************************************************************************************************/
void LDL_Abort(const char* message, const char* detail)
{
	printf("%s %s/n", message, detail);
	abort();
}

void LDL_Abort(const char* message)
{
	LDL_Abort(message, "");
}

void LDL_Abort()
{
	LDL_Abort("", "");
}
/********************************************************************************************************************************
														  Memory management
********************************************************************************************************************************/
void* LDL_malloc(size_t bytes, const char* file, int line)
{
	void* result = malloc(bytes);

	if (result == NULL)
	{
		printf("Memory allocation error: File: %s Line: %d", file, line);
		LDL_Abort();
	}

	return result;
}

#define LDL_malloc(x) LDL_malloc(x, __FILE__, __LINE__)

void LDL_free(void* ptr, const char* file, int line)
{
	if (ptr == NULL)
	{
		printf("Passed pointer is null: File: %s Line: %d", file, line);
		LDL_Abort();
	}

	free(ptr);
}

#define LDL_free(x) LDL_free(x, __FILE__, __LINE__)
/********************************************************************************************************************************
															LDL_Allocator
********************************************************************************************************************************/
class LDL_Allocator
{
public:
	enum
	{
		Kb = 1024,
		Mb = Kb * 1024,
		Gb = Mb * 1024
	};
	virtual void* Allocate(size_t bytes) = 0;
	virtual void Deallocate(void* ptr) = 0;
	virtual size_t UsedBytes() = 0;
	virtual void Reset() = 0;
private:
};
/********************************************************************************************************************************
														LDL_FixedLinear
********************************************************************************************************************************/
class LDL_FixedLinear : public LDL_Allocator
{
public:
	LDL_FixedLinear(size_t bytes, LDL_Allocator* allocator) :
		_Capacity(bytes),
		_Position(0),
		_Content(NULL),
		_Allocator(allocator)
	{
		if (_Allocator)
			_Content = (uint8_t*)_Allocator->Allocate(_Capacity);
		else
			_Content = (uint8_t*)LDL_malloc(_Capacity);
	}

	~LDL_FixedLinear()
	{
		if (_Allocator)
			_Allocator->Deallocate(_Content);
		else
			LDL_free(_Content);
	}

	void* Allocate(size_t bytes)
	{
		assert(bytes > 0);
		assert(_Position + bytes <= _Capacity);

		void* result = _Content + _Position;

		_Position += bytes;

		return result;
	}

	void Deallocate(void* ptr)
	{
		assert(ptr != NULL);
	}

	size_t UsedBytes()
	{
		return _Position;
	}

	void Reset()
	{
		_Position = 0;
	}
private:
	size_t _Capacity;
	size_t _Position;
	uint8_t* _Content;
	LDL_Allocator* _Allocator;
};
/********************************************************************************************************************************
															LDL_BmpLoader
********************************************************************************************************************************/
struct BmpFileHeader
{
	uint16_t bfType;
	uint32_t bfSize;
	uint16_t bfReserved1;
	uint16_t bfReserved2;
	uint32_t bfOffBits;
};

struct BmpInfoHeader
{
	uint32_t biSize;
	int32_t  biWidth;
	int32_t  biHeight;
	uint16_t biPlanes;
	uint16_t biBitCount;
	uint32_t biCompression;
	uint32_t biSizeImage;
	int32_t  biXPelsPerMeter;
	int32_t  biYPelsPerMeter;
	uint32_t biClrUsed;
	uint32_t biClrImportant;
};

class LDL_BmpLoader
{
public:
	LDL_BmpLoader(LDL_Result* result) :
		_Result(result),
		_Pixels(NULL),
		_Input(NULL),
		_Bpp(0)
	{
		memset(&_FileHeader, 0, sizeof(_FileHeader));
		memset(&_InfoHeader, 0, sizeof(_InfoHeader));
	}

	~LDL_BmpLoader()
	{
		if (_Pixels)
		{
			LDL_free(_Pixels);
		}
	}

	bool Load(const char* path)
	{
		if (CheckOpen(path))
		{
			if (CheckFileHeader())
			{
				if (CheckInfoHeader())
				{
					if (ReadBytes())
					{
						BgrToRgb();

						return true;
					}
				}
			}

			fclose(_Input);
		}

		return false;
	}

	const LDL_Vec2i& Size()
	{
		return _Size;
	}

	uint8_t Bpp()
	{
		return _Bpp;
	}

	uint8_t* Pixels()
	{
		return _Pixels;
	}
private:
	void BgrToRgb()
	{
		size_t count = Size().x * Size().y * Bpp();

		uint8_t b = 0;
		uint8_t r = 0;

		for (size_t i = 0; i < count; i += 3)
		{
			b = _Pixels[i];
			r = _Pixels[i + 2];

			_Pixels[i] = r;
			_Pixels[i + 2] = b;
		}
	}

	bool CheckOpen(const char* path)
	{
		_Input = fopen(path, "rb");

		if (_Input == NULL)
		{
			_Result->Message("Not found file: ", path);
		}

		return _Result->Ok();
	}

	bool CheckFileHeader()
	{
		fread(&_FileHeader.bfType, sizeof(_FileHeader.bfType), 1, _Input);
		if (_FileHeader.bfType != 0x4D42)
			_Result->Message("bfType is invalid");

		fread(&_FileHeader.bfSize, sizeof(_FileHeader.bfSize), 1, _Input);
		if (_FileHeader.bfSize == 0)
			_Result->Message("bfSize is invalid");

		fread(&_FileHeader.bfReserved1, sizeof(_FileHeader.bfReserved1), 1, _Input);
		if (_FileHeader.bfReserved1 != 0)
			_Result->Message("bfReserved1 is invalid");

		fread(&_FileHeader.bfReserved2, sizeof(_FileHeader.bfReserved2), 1, _Input);
		if (_FileHeader.bfReserved2 != 0)
			_Result->Message("bfReserved2 is invalid");

		fread(&_FileHeader.bfOffBits, sizeof(_FileHeader.bfOffBits), 1, _Input);
		if (_FileHeader.bfType == 0)
			_Result->Message("bfOffBits is invalid");

		return _Result->Ok();
	}

	bool CheckInfoHeader()
	{
		fread(&_InfoHeader.biSize, sizeof(_InfoHeader.biSize), 1, _Input);
		if (_InfoHeader.biSize == 0)
			_Result->Message("biSize is invalid");

		fread(&_InfoHeader.biWidth, sizeof(_InfoHeader.biWidth), 1, _Input);
		if (_InfoHeader.biWidth == 0)
			_Result->Message("biWidth is invalid");

		fread(&_InfoHeader.biHeight, sizeof(_InfoHeader.biHeight), 1, _Input);
		if (_InfoHeader.biHeight == 0)
			_Result->Message("biHeight is invalid");

		fread(&_InfoHeader.biPlanes, sizeof(_InfoHeader.biPlanes), 1, _Input);
		fread(&_InfoHeader.biBitCount, sizeof(_InfoHeader.biBitCount), 1, _Input);
		fread(&_InfoHeader.biCompression, sizeof(_InfoHeader.biCompression), 1, _Input);
		fread(&_InfoHeader.biSizeImage, sizeof(_InfoHeader.biSizeImage), 1, _Input);
		fread(&_InfoHeader.biXPelsPerMeter, sizeof(_InfoHeader.biXPelsPerMeter), 1, _Input);
		fread(&_InfoHeader.biYPelsPerMeter, sizeof(_InfoHeader.biYPelsPerMeter), 1, _Input);
		fread(&_InfoHeader.biClrUsed, sizeof(_InfoHeader.biClrUsed), 1, _Input);
		fread(&_InfoHeader.biClrImportant, sizeof(_InfoHeader.biClrImportant), 1, _Input);

		_Size = LDL_Vec2i(_InfoHeader.biWidth, _InfoHeader.biHeight);
		_Bpp = _InfoHeader.biBitCount / 8;

		return _Result->Ok();
	}

	bool ReadBytes()
	{
		size_t bytes = _Bpp * _Size.x * abs(_InfoHeader.biHeight);

		_Pixels = (uint8_t*)LDL_malloc(bytes);

		assert(_Pixels != NULL);

		size_t result = fread(_Pixels, bytes, 1, _Input);

		if (result != 1)
		{
			_Result->Message("Not enough byte data");
		}

		return _Result->Ok();
	}

	LDL_Result* _Result;
	uint8_t* _Pixels;
	FILE* _Input;
	BmpFileHeader _FileHeader;
	BmpInfoHeader _InfoHeader;
	LDL_Vec2i _Size;
	uint8_t _Bpp;
};
/********************************************************************************************************************************
															Ticks
********************************************************************************************************************************/
#if defined(_WIN32)
size_t LDL_Ticks()
{
	return timeGetTime();
}

void LDL_Delay(size_t count)
{
	Sleep((DWORD)count);
}
#elif defined(__MSDOS__)
size_t LDL_Ticks()
{
	return 0;
}

void LDL_Delay(size_t count)
{
}
#elif defined(__unix__)
size_t LDL_Ticks()
{
	struct timeval tv;

	gettimeofday(&tv, NULL);

	return (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
}

void LDL_Delay(size_t count)
{
	if (count >= 1000)
		sleep(count / 1000);

	usleep((count % 1000) * 1000);
}
#endif
/********************************************************************************************************************************
														  LDL_Library
********************************************************************************************************************************/
#if defined(_WIN32)
class LDL_Library
{
public:
	bool Open(const char* path)
	{
		Close();

		_HMODULE = LoadLibrary(path);

		return _HMODULE != NULL;
	}

	void Close()
	{
		if (_HMODULE != NULL)
		{
			FreeLibrary(_HMODULE);
		}
	}

	~LDL_Library()
	{
		Close();
	}

	LDL_VoidFuncPtr Function(const char* name)
	{
		return (LDL_VoidFuncPtr)GetProcAddress(_HMODULE, name);
	}
private:
	HMODULE _HMODULE;
};
#elif defined(__unix__)
class LDL_Library
{
public:
	bool Open(const char* path)
	{
		Close();

		_Library = dlopen(path, RTLD_NOW | RTLD_GLOBAL);

		return _Library != NULL;
	}

	void Close()
	{
		if (_Library != NULL)
		{
			dlclose(_Library);
		}
	}

	~LDL_Library()
	{
		Close();
	}

	LDL_VoidFuncPtr Function(const char* name)
	{
		return (LDL_VoidFuncPtr)dlsym(_Library, name);
	}
private:
	void* _Library;
};
#endif
/********************************************************************************************************************************
													   LDL_OpenGLFunctions
********************************************************************************************************************************/
#if defined(_WIN32)
class LDL_OpenGLFunctions
{
public:
	LDL_OpenGLFunctions()
	{
		_Library.Open("opengl32.dll");
	}

	~LDL_OpenGLFunctions()
	{
		_Library.Close();
	}

	LDL_VoidFuncPtr Function(const char* name)
	{
		LDL_VoidFuncPtr result = (LDL_VoidFuncPtr)wglGetProcAddress(name);

		if (IsValid(result))
		{
			result = _Library.Function(name);

			if (result == NULL)
			{
				LDL_Abort("Not found function:", name);
			}
		}

		return result;
	}
private:
	bool IsValid(LDL_VoidFuncPtr ptr)
	{
		return (ptr == 0 || (ptr == (LDL_VoidFuncPtr)0x1) || (ptr == (LDL_VoidFuncPtr)0x2) || (ptr == (LDL_VoidFuncPtr)0x3) || (ptr == (LDL_VoidFuncPtr)-1));
	}

	LDL_Library _Library;
};
#elif defined(__unix__)
class LDL_OpenGLFunctions
{
public:
	LDL_OpenGLFunctions()
	{
		_Library.Open("opengl32.dll");
	}

	~LDL_OpenGLFunctions()
	{
		_Library.Close();
	}

	LDL_VoidFuncPtr Function(const char* name)
	{
		LDL_VoidFuncPtr result = (LDL_VoidFuncPtr)glXGetProcAddress((const GLubyte*)name);

		if (result == NULL)
		{
			LDL_Abort("Not found function:", name);
		}

		return result;
	}
private:
	LDL_Library _Library;
};
#endif
/********************************************************************************************************************************
													   LDL_FpsCounter
********************************************************************************************************************************/
class LDL_FpsCounter
{
public:
	LDL_FpsCounter() :
		_Current(0),
		_Delta(0),
		_Old(0),
		_Fps(0)
	{
	}

	void Start()
	{
		_Current = LDL_Ticks();
	}

	bool Calc()
	{
		_Fps++;

		_Delta = LDL_Ticks() - _Current;

		_Old += _Delta;

		if (_Old >= 1000)
		{
			return  true;
		}

		return false;
	}

	size_t Fps()
	{
		return _Fps;
	}

	void Clear()
	{
		_Fps = 0;
		_Old = 0;
	}
private:
	size_t _Current;
	size_t _Delta;
	size_t _Old;
	size_t _Fps;
};
/********************************************************************************************************************************
													   LDL_FpsLimiter
********************************************************************************************************************************/
class LDL_FpsLimiter
{
public:
	LDL_FpsLimiter(size_t fps = 60) :
		_Fps(fps),
		_Ticks(0)
	{
	}

	void Mark()
	{
		_Ticks = LDL_Ticks();
	}

	void Throttle() const
	{
		if (1000 / _Fps > LDL_Ticks() - _Ticks)
		{
			LDL_Delay(1000 / _Fps - (LDL_Ticks() - _Ticks));
		}
	}
private:
	size_t _Fps;
	size_t _Ticks;
};

#endif
